import Live #@UnusedImport @UnresolvedImportfrom _Framework.SessionComponent import SessionComponent#from _Framework.ButtonElement import ButtonElement#from ConfigurableButtonElement import ConfigurableButtonElementfrom _liveUtils.Logger import log #@UnresolvedImport @UnusedImportfrom consts import * #@UnusedWildImportclass SpecialSessionComponent(SessionComponent):	' SPECIAL SESSION SUBCLASS THAT HANDLES CONFIGURABLEBUTTONS '	__module__ = __name__	" INIT "	def __init__(self, parent, num_tracks, num_scenes, side_buttons):		self._tracks_and_listeners = []		self._parent = parent		self._num_scenes = num_scenes		self._side_buttons = side_buttons		SessionComponent.__init__(self, num_tracks, num_scenes)	" DISCONNECT - remove all listeners"	def disconnect(self):		self.remove_listeners()		SessionComponent.disconnect(self)		" REMOVE LISTENERS "	def remove_listeners(self):		for index in range(len(self._tracks_and_listeners)):			track = self._tracks_and_listeners[index][0]			fire_listener = self._tracks_and_listeners[index][1]			playing_listener = self._tracks_and_listeners[index][2]			if (track != None):				if track.fired_slot_index_has_listener(fire_listener):					track.remove_fired_slot_index_listener(fire_listener)				if track.playing_slot_index_has_listener(playing_listener):					track.remove_playing_slot_index_listener(playing_listener)		#self._tracks_and_listeners = []	"  OVERWRITE FROM BASE CLASS"	def _reassign_scenes(self):		log("_reassign_scenes")				SessionComponent._reassign_scenes(self)		self._recolor_scenes()	" REASSIGN SCENES "			def _recolor_scenes(self):		log("_recolor_scenes")		for scene_index in range(self._num_scenes):			scene = self.scene(scene_index)				if scene != None:				if scene._scene != None:					scene_color = scene._scene.color							# set off color depending on scene color					off_color = LED_OFF					if scene_color == 16777215: #white						off_color = RED_HALF					scene_button = self._side_buttons[scene_index]					if scene_button != None:						scene_button.set_on_off_values(127, off_color)						scene_button.turn_off()	" REASSIGN TRACKS "	def _reassign_tracks(self):		self.remove_listeners()		tracks_to_use = self.tracks_to_use()		button_index = 0		for index in range(self._num_tracks):						if self.song().tracks[index].is_foldable:				if button_index < GROUPS_CONSIDERED:					fire_listener = lambda var1 = index:self._on_fired_slot_index_changed(var1)					playing_listener = lambda var1 = index:self._on_playing_slot_index_changed(var1)					track = None					if ((self._track_offset + index) < len(tracks_to_use)):						track = tracks_to_use[(self._track_offset + index)]					if (track != None):						self._tracks_and_listeners.append((track, fire_listener, playing_listener))						track.add_fired_slot_index_listener(fire_listener)						track.add_playing_slot_index_listener(playing_listener)					self._update_stop_clips_led(index)					button_index = button_index + 1			else:				fire_listener = lambda var1 = index:self._on_fired_slot_index_changed(var1)				playing_listener = lambda var1 = index:self._on_playing_slot_index_changed(var1)				track = None				if ((self._track_offset + index) < len(tracks_to_use)):					track = tracks_to_use[(self._track_offset + index)]				if (track != None):					self._tracks_and_listeners.append((track, fire_listener, playing_listener))					track.add_fired_slot_index_listener(fire_listener)					track.add_playing_slot_index_listener(playing_listener)				self._update_stop_clips_led(index)	" CALLBACK FIRE"	def _on_fired_slot_index_changed(self, index):		#log("on fired slot index changed " + str(index))		self._update_stop_clips_led(index)	" CALLBACK PLAYING "	def _on_playing_slot_index_changed(self, index):		#log("on playing slot index changed " + str(index))		self._update_stop_clips_led(index)	" STOP LEDS"	def _update_stop_clips_led(self, index):		if (self.is_enabled() and (self._stop_track_clip_buttons != None)):			# find group index			#log("update stop clip leds (for index): " + str(index))			tracks = self.song().tracks					#group_nr = 0			group_index = 0			for idx in range(index):				if tracks[idx].is_foldable:					#group_nr = group_nr + 1					group_index = idx			#log("group number: " +str(group_nr))			#log("corresponding track: " +str(group_index))						# called for a group			if tracks[index].is_foldable:				#log("UPDATE STOP CLIP LED CALLED FOR A GROUP")				index = index + 1							# do for all until next group or end			playing_count = 0			stopping_count = 0			next_group_passed = False			for track_index in range(len(tracks)):				track = tracks[track_index]				if (track_index > group_index) and (next_group_passed == False):					if track.is_foldable:						next_group_passed = True					else:						if track.fired_slot_index == -2:							stopping_count = stopping_count + 1						elif track.playing_slot_index >= 0:							playing_count = playing_count + 1			# set the color			#log("playing: " + str(playing_count) + ", stopping: " + str(stopping_count))						button = self._stop_track_clip_buttons[group_index]			if not isinstance(button, type(None)):				#log(button.name)				if (playing_count > 0):					button.turn_on()				elif(stopping_count > 0):					button.send_value(AMBER_BLINK)				else:					button.turn_off()			#log("")	""" SETUP STOP BUTTONS """	def set_stop_track_clip_buttons(self, buttons):		assert ((buttons == None) or (isinstance(buttons, tuple) and (len(buttons) <= self._num_tracks)))		#remove old listener		if (self._stop_track_clip_buttons != None): 			for button in self._stop_track_clip_buttons: 				if button != None:					if button.value_has_listener(self._on_stop_track_value):						button.remove_value_listener(self._on_stop_track_value)			self._stop_track_clip_buttons = None		# add new listeners		if (self.is_enabled() and buttons != None):			assert ((buttons == None) or (isinstance(buttons, tuple))) 			self._stop_track_clip_buttons = buttons						  			if (self._stop_track_clip_buttons != None):				button_index = 0				for track_index in range(len(self.song().tracks)):					if self.song().tracks[track_index].is_foldable:						if button_index < GROUPS_CONSIDERED:							button = self._stop_track_clip_buttons[track_index]							button.add_value_listener(self._on_stop_track_value, identify_sender=True)								self._on_fired_slot_index_changed(list(self._stop_track_clip_buttons).index(button)) 							button_index = button_index + 1		self.update()